import java.awt.*;
import java.util.Scanner;	//导入 java.util 包下的 Scanner 类
public class JavaEveryday {
/*------------第一篇章：Java入门------------
以下笔记摘自Java网课资源和网络网站教程
@计算机知识：
	* 存储与储存
	 * 存储多用于虚拟物质或无法确定实体物质的存储。(在计算机中多使用存储)
	 * 储存多用于实体物质的储存，对象是实在的不需要载体或其他形式就能直接发挥作用。
	 * 常说的C、D、E、F盘其实是硬盘（Hard Disk Drive 简称HDD，又称硬盘驱动器）的分区。
	* 计算机编程语言
	 * 计算机编程语言是程序设计的最重要的工具，它是指计算机能够接受和处理的、具有一定语法规则的语言。
	 * 从计算机诞生，计算机语言经历了机器语言、汇编语言和高级语言几个阶段
	 * 机器语言与二进制（机器是语言最先出生的编程语言，面向机器）
	  * 人们生活采用十进制数，而计算机中全部采用二进制数表示，它只包含0、1两个数，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特）。
	  * 只用“1”和“0”两个数字就可以进行编程的机器语言难学难懂、不可移植、编程繁杂，但速度极快。
	 * 汇编语言（第二代计算机语言）
	  * 它助记符代替了机器语言中的操作码，用地址符号或标号代替了指令或操作数地址。
	  * 比起机器语言，汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言。
	 * 高级编程语言（High-level programming language）
	  * 它是一种独立于机器，面向过程或对象的语言。高级语言是参照数学语言而设计的近似于日常会话的语言。
	  * 首个高级编程语言为1956年的FORTRAN
	  * 各类高级编程语言概述
	    Java（面向对象）：服务器端最好的编程语言
		C++（面向对象）：最通用的编程语言
		C（面向过程）：迄今为止，最值得信任的编程语言
		Python（面向过程或对象）：AI（人工智能）、机器学习方向最佳的编程语言
		JavaScript（支持面向对象）：客户端最常用的脚本语言
		C#（面向对象）：微软最强有力的面向对象编程语言
		Swift（面向过程或对象）：IOS 端最高效的编程语言
		GO(Golang)（不完全是面向对象，go的结构体不支持继承但支持嵌套/组合）：可扩展的编程语言，谷歌出品
		PHP（面向过程或对象）：“世界上最好的编程语言”(web开发)
		Ruby（面向对象）：数据科学方面最可靠的编程语言
	 *为什么选择java?
	  * java简单易学：
	   * java内置了一套庞大的库类，程序员可以基于类库进行“二次”开发(开发速度较快，JDK内置库实现了很多基础的功能)
	   * JDK源代码位置C:Program Files\Java\jdk-xx.x.x\lib\src.zip(默认安装路径时，src.zip文件需要解压才能查看)
@Java诞生于1995年美国SUN公司（被oracle公司收购）。
@Java程序的运行机制：
    *  java文件→编译器(javac)→字节码文件(.class)→对应系统的JVM(java虚拟机)→操作系统
    *  java属于半编译型半解释型的计算机高级语言类型。
@JVM(Java虚拟机),JRE(运行环境),JDK(开发工具箱)
	* JDK/bin：该目录下存放了很多命令，例如javac.exe(负责编译)和java.exe(负责运行)
    * Java Virtual Machine(JVM):
       用于执行bytecode字节码的“虚拟计算机”。包含Just in Time Compiler(JIT)
       不同的操作系统有不同版本的JVM，它屏蔽了底层运行平台的差异，是JAVA实现跨平台的核心。
    * Java Runtime Environment(JRE) 包含:java,javaw,libraries,rt.jar
    * Java Development Kit(JDK) 包含:javac,jar,debugging,tools,javap
    * JVM∈JRE∈JDK
*//*Java程序的两个运行阶段
	1.编译阶段
	  - 编译阶段主要的任务是检查Java源程序是否符合Java语法，
	  符合Java语法则能够生成正常的字节码文件(xxx.class)
	  不符合Java语法规则则无法生存字节码文件
	  - 字节码文件不是纯粹的二进制，这种文件无法在操作系统当中直接执行。
	  - 编译阶段的过程：
	  	* 程序员需要在硬盘的某个位置<位置随意>新建一个.java扩展名的文件，
		该文件被称为Java源文件，源文件当中编写的是Java源代码/源程序。
		而这个源程序是不能随意编写的，其必须符合Java语法规则<Java语法规则是需要记忆的>
	    * Java程序员需要需要使用JDK当中自带的javac.exe命令进行Java程序的编译。
			javac的使用规则：
				javac java源文件绝对路径或相对路径.java（路径用引号引起来，且要带上.java，同级目录下则可带可不带）
		* 一个java源文件可以编译生成多个.class文件。
		* 字节码文件/class文件是最终要执行的文件，所以说class文件生成之后，java源文件删除并不会影响java程序的运行。
		  但是class文件最终执行结果不一定是我们想要的，此时我们需要重新修改java源文件，然后将java源程序重新编译生成新的class文件，然后再运行这个class程序，生成新的效果
		* 编译结束之后，可以将class文件拷贝到其他操作系统当中运行。
	2.运行阶段
	  - JDK安装之后，除了自带一个javac.exe之外，还有一个工具/命令叫做java.exe
	  java.exe命令主要负责运行阶段。
	    * java.exe的使用规则：
			java 类名（不需要带上文件格式）
	  - 运行阶段的过程是：
	  	* 打开DOS窗口，输入:java  A
		* java.exe命令会启动java虚拟机(JVM)，JVM会启动类加载器ClassLoader
		* ClassLoader会去硬盘上搜索A.class文件，找到该文件则将该字节码文件装载到JVM当中。
		* JVM将A.class字节码文件解释成二进制(由0和1组成，逢2进1)。
		* 然后操作系统(OS)执行二进制和底层硬件平台进行交互。
  *///@注释
//单行注释
/*多行注释
注意：多行注释不能嵌套使用，注释不会出现在字节码文件中*/
/**文档(javadoc)注释(会被工具bin\javadoc.exe提取解析并生成对应的帮助文档，详细请自搜)*/
//public表示公开的，class表示定义一个类，JavaEveryday表示该类的类名
//公共类有且只有一个，要和文件名相符
  /*public class JavaEveryday（文件名，但不包含后缀） {
	//类体中不允许直接编写java语句【声明变量除外】
	//注：static表示静态的，void表示空，main表示方法名是main，(String[] args)是一个main方法的形式参数列表
    public<访问修饰符>static<关键字>void<返回类型>main<方法名>(String[]<String类>args<字符串数组>) {	//注：该 方法体 表示定义一个公开的静态主方法，主方法是程序的入口，属于硬性规定。但args部分（Arguments的缩写，是指字符串变量名）可以自定义，且DOS窗口中可以用带参数的运行命令“java JavaEveryday <内容>”传入参数，在文档中“args[0]”是传入的第一个参数，“args[1]”是传入的第二个参数（传入时用空格分隔），以此类推。
        System.out.println("Hello World");		//java语句：一个语句可以跨多行，但必须以";"(半角)结束。该语句的作用是向控制台输出一段消息，java中所有的“字符串”都使用双引号括起来。
		// 另方法体当中的java代码，是遵循自上而下的顺序依次逐行执行的。
	}
*//*public class 和 class的区别：
	* 一个java源文件当中可以定义多个class，每个类都可以编写入口(main方法)，且可以通过java+类名运行。
	* 一个java源文件中public class不是必须的
	* 一个class会定义生成一个xxx.class字节码文件
	* 一个java源文件只能有一个public修饰的类，并且该类名必须和java源文件名一致。
	* 每一个class当中都可以编写main方法，都可以设定程序的入口，若要执行B.class中的main方法，则需要输入java B，执行X.class当中的main方法，输入java X，如果没有main方法，则无法执行。
*//*@常用DOS命令
  路径：
  	 绝对路径：以盘符为起点的路径
	 相对路径：是相对于当前所在位置而言的
  DOS全称磁盘操作系统(Disk Operating System)
     1.javac 文件名/“绝对路径”.java(单文件名为当前目录下，绝对相对路径不在同目录下都需要加引号) ————将指定文件编译为.class字节码文件
     2.java 类名(当前目录下，不是文件路径) ————执行指定的.class字节码文件
	 3.盘符名: ————切换到指定盘符
	 4.cd <目录路径> ————进入一个目录
     5.cd .. ————进入父目录（及上级目录，一个点为当前目录，比如classpath(环境变量当中类加载器的执行默认目录)的配置可以=.）
	 6.cd \ ————直接回到根目录
     7.dir ————查看本目录下的文件和子目录列表
     8.cls ————清屏
     9.↑↓键 ————粘贴上/下一条命令
     10.Tab键 ————自动补齐命令
	 11.mkdir xxx ————在当前目录下创建一个名为xxx的文件夹
	 12.del <路径> ————删除文件（如del *.class删除当前目录下所有class文件，通配符“*”代表全部）
	 13.rd <路径> ————删除空文件夹，删除文件夹及子文件：rd /s test，删除文件夹及子文件且不询问；rd /q /s test
	 14.ipconfig ————查看IP地址等信息，查看更详细的信息使用ipconfig /all（详细信息包括物理(MAC)地址）
	 15.ping <ip地址/域名>————查看两台计算机的通信情况，可以跟上“-t”参数一直ping，便于查看网络是否稳定
	 16.Ctrl + c ————强制终止正在执行的命令
	 17.exit 退出DOS命令窗口
*//*@文本编辑器常用快捷键：
	 1.Ctrl + c ————复制
	 2.Ctrl + x ————剪切
	 3.Ctrl + v ————粘贴
	 4.Ctrl + s ————保存
	 5.Ctrl + z ————撤销
	 6.Ctrl + y ————重做
	 7.Ctrl + a ————全选
	 8.Ctrl + f ————查找
*//*@标识符（可自主命名的元素）、关键字和字面值（数据）
	 * 标识符：
      1.必须以字母、下划线"_"、美元符号"$"或中文开头，但不建议使用中文。
      2.首字符之后可以是字母,美元符"$"、下划线"_"或数字的任何字符组合
      3.大小写敏感，长度没有限制（如果java源文件中同时出现了只有大小写不同的类，那么谁在前就生成谁）。
      4.不可以是Java的关键字，标识符内也不能有空格。
	  5.驼峰命名规范：
	 	 * 类名、接口名：首字母大写，后面每个单词首字母大写。
		 * 变量名、方法名：首字母小写，后面每个单词首字母大写
		 * 常量名：全部大写，并且单词和单词之间采用下划线衔接
	 * 关键字：Java中关键字都是小写的
	 * 颜色：在EditPlus中，蓝色-关键字；黑色-标识符；红色-SUN公司的JDK写好的一个类。
	 * 字面值（数据）：
	  1.是java源程序的组成部分之一。包括标识符和关键字都是它们都是java源程序的组成部分。
	  2.java语言当中所有的字符串型字面值必须使用双引号引起来（即使一个字符用双引号引起来也是字符串型）；字符型字面值必须使用单引号引起来，且只能存放单个字符。
	  3.再任何情况下，整数型的字面量会被默认当做int类型处理，如果希望该整数型字面量被当作long类型来处理，需要在字面量后面加L/l（建议大写以便区分数字1）
*//*@变量(Variable)
	 * 变量是内存中存储单元的最基本的单元。
	 * 变量分为局部变量和成员变量：
	   * 局部变量 - 在方法体外当中声明的变量（局部变量只在方法体中有效，方法体执行结束该变量的内存就释放了）
	   * 成员变量 - 在方法体外【类体之内】声明的变量
	 * 变量本质上是“可操作的内存空间”，这块空间有数据类型、名称、字面值，即变量的三要素。
	 * 在同一个作用域中变量名不能重名，不同的作用域则可以重名，例如：成员变量与局部变量可以重名(就近原则)，并列的局部变量可以重名(互不影响)，。
     * 声明格式：
		基本：数据类型 变量名 = 字面量;（“=”是赋值运算符，声明和赋值可以一起完成也可以分开，且赋值后仍然可以重新赋值）
		type identifier [ = value][, identifier [= value] ...] ;   type为Java数据类型。identifier是变量名。
     * Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小
	 * 成员变量没有手动赋值系统会默认赋值
	   * 八种数据类型的默认值：
		   byte,short,int,long为0；float,double为0.0；boolean为false；char为\u0000
	 * 变量的引出：
	   * 如：System.out.print(10);System.out.print(10);	 这两次打印虽然内容相同，但这两个10会占用两处不同的内存空间，所以只有字面量时内存是无法重复利用的。
			 int i = 10;System.out.print(i);System.out.print(i);	定义/声明一个变量，通过打印变量的值，可以使这两次访问都指向同一个内存空间，提高了内存的利用率。
*/
    static int b;	//这个是成员变量(方法体外)，特别的，成员变量没有手动赋值系统会默认赋值【局部变量不会】
    public static void testVariable(){      //case 1：@变量测试testVariable
        int age = 11;		//这些都是局部变量
        int x;    //除了给变量声明数据类型，还要对它进行初始化。
		x = 5;
        int y=1,z=4;    //一行可以声明多个变量，用“,”分隔不同变量。
        System.out.println("age="+age);
        System.out.println("b="+b);
        System.out.println("x+y+z="+(x+y+z));
    }
  /*执行结果：
    @变量测试testVariable：
    age=11
    b=0
    x+y+z=10
  */
  /*@变量有三种类型，分别为 局部变量、成员变量（实例变量）、静态变量（类变量），其中
     *局部变量在方法或语句块内部声明，从属于方法/语句块，它从声明位置开始，直到方法或语句块执行完毕，局部变量才消失。
     *成员变量在类内部，方法外部声明，从属于对象，他随着对象的创建而创建，随着对象的消失而消失。
     *静态变量在类内部声明，被Static修饰，从属于类，类被加载，静态变量就有效；类被卸载，静态变量会失效。
*//*@常量(Constant)
     *声明格式：final type varName = value
*/
    public static void testConstant(){      //case 2：@常量测试testConstant
        final double PI = 3.14;     //PI作为常量出现，无法再次分配值。
        final int MAX_SPEED = 120;      //常量的命名：全用大写字母，单词之前用下划线隔开。

        int r = 4;
        double area = PI*r*r;
        double circle = 2*PI*r;
        System.out.println("r=4时，面积是："+area);
        System.out.println("r=4时，周长是："+circle);
    }
  /*执行结果：
    @常量测试testConstant：
    r=4时，面积是：50.24
    r=4时，周长是：25.12
  */
  /*@整型常、变量和各种进制
     * 十进制整数，如：31
     * 八进制整数，要求以 0 开头，如：037
     * 十六进制整数，要求以 0x 或 0X 开头，如：0x1f
     * 二进制数，要求 0b 或 0B 开头，如0b11111
     */
    public static void testInt() {      //case 3：@整型常、变量和各种进制testInt
        int a = 31, a8 = 037, a16 = 0x1f, a2 = 0b11111;
        System.out.println("（十进制）31="+a);
        System.out.println("（八进制）037="+a8);
        System.out.println("（十六进制）0x1f="+a16);
        System.out.println("（二进制）0b11111="+a2);

        byte b = 127;	 //byte表数范围(-128 ~ 127)
        short c = 32767;    //short表数范围(-32768 ~ 32767)
        int salary = 30000000;	//整型常量默认类型是int，int表数范围(-2,147,483,648 ~ 2,147,483,647)
        long yearSalary = 3600000000L;  //数字后的l是把整形常量定义为long类型，long表数范围(-2^63 ~ 2^63-1)
        System.out.println("月薪为30000000时，年薪为"+yearSalary);
    }
  /*执行结果：
    @整型常、变量和各种进制testInt：
    （十进制）31=31
    （八进制）037=31
    （十六进制）0x1f=31
    （二进制）0b11111=31
    月薪为30000000时，年薪为3600000000
  */
  /*@基本数据类型(primitive data type)
	 * Java虚拟机会根据不同的数据类型，给数据分配不同大小的空间
     * Java中数据类型分为 基本数据类型(见下） 和 引用数据类型(String、java.math.BigDecimal...)
	 * 数据类型是指导程序在运行阶段应该分配多大的内存空间。不同的数据又不同的类型，不同的数据类型底层会分配不同大小的空间。
     * 1个字节 等于 8个比特位（1 Byte = 8 bit），1个比特位表示一个二进制位：1/0
	   其他：1 KB = 1024Byte；1 MB = 1024 KB；1 GB = 1024 MB；1 TB = 1024 GB
	基本数据类型包含
     1.数值型{
        整数型(byte 数据类型8位;short 数据类型16位;int 数据类型32位;long 数据类型64位)
        浮点型(float 数据类型是单精度、32位;double 数据类型是双精度、64位)
         }
     2.字符型  char 类型是一个单一的16位Unicode字符；
     3.布尔型  boolean 数据类型表示一位的信息，只有两个取值true和false；
*//*@自动类型转换
   * 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型(byte —> short ; byte,short,char —> int —> long/double ; float —> double)
   * 在int -> float ; long -> float/double 的过程中可能会有精度的损失
   * 不能对boolean类型进行类型转换，同时，也不能把对象类型转换成不相关类的对象。
   * 多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型(char、short、byte之间的的混合运算除外，详见“特例”)
   * 容量从小到大的排序：
   		byte < short(char) < int < long < float < double，其中short和char的容量大小相同都为两个字节，但是char可以表示更大范围的正整数。
   * 特例：
		1.byte、char、short做混合运算时，各自先转换成int类型再进行运算，结果也默认为int类型
        2.整型常量默认是int类型，所以在给byte/short/char数据类型赋值的过程中，其实质是int类型的数据转为容量更小的数据类型，这意味着在不超出byte/short/char数据类型的范围时，int数据类型的值可以被转换成它们的数据类型。
		PS：由于编译器无法读取变量对应的字面值，所以在应用特例第2条时不能给byte/short/char类型变量赋值未知的int类型数据，即不能赋值带变量的表达式，无论结果是否超出目标数据类型，都会被判断为可能损失精度，需要手动强制类型转换
*//*@二进制的原码、补码、反码（衔接强制类型转换）
	 * 计算机再底层存储数据的时候，一律存储的是“二进制的补码形式”
	 * 对于一个正整数来说：二进制的原码、补码、反码是同一个，完全相同。
	 * 对于一个负数来说：反码是二进制原码符号位不变，其它位取反；补码为反码加1的结果（如byte的-1，是负数，二进制原码为10000001，转换成反码为11111110，补码则为11111111）
*//*@强制类型转换(cast)
   * 使用方法：(type)var
   * 可能会损失精度，例如，浮点型强转为整数，直接丢失小数部分。
   * 如果强制转型超出了表数范围，则会转成一个完全不同的的值
		精度损失的强转底层逻辑：
		1.将数转成二进制，先求其补码(正数的补码是其本身，负数的补码是原码的 数值部分按位取反 后再 加1)
		2.然后从右向左截取该二进制补码到目标数值类型的最大长度作为补码，再依据截取出来的数字的符号位判断正负（强制转型不会保留原先字面值的正负性，转换结果的正负性取决于转换结果最左边的第一位是1还是0，1为负，0为正）
		3.若为整数，则原码反码补码相同，可直接转换成数字；若为负数，则逆推导其原码，先求反码(该补码减1)，再求原码(对该反码数值部分按位取反。保留符号位)，然后再把符号位转成对应的符号，1为负，0为整数，剩下的数字部分转成十进制的数字）
*//*@浮点型(Floating Point Number)
     * float类型又被称为单精度类型，尾数可以精确到7位有效数字。
     * double表示这种类型的数值精度约是float类型的两倍，所以又称双精度类型，绝大部分应用程序都采用double类型。
	 * 尽管float占用4个字节，double占用8个字节，由于float实现原理很复杂，我们还是认为float容量较大，且float容量 > long容量，且任意一个浮点型都比整数型空间大。
     * 浮点数型不精确，尽量不要用于比较。（精度要求非常高的商业计算要使用BigDecimal进行运算和比较，它不属于基本数据类型，属于引用数据类型）
     * 浮点数常量默认类型是double，要改成float可以在常数后面加”F”或”f”，或者直接通过强制类型转换，但是该方法会导致精度的损失，需要谨慎使用。
    @Java浮点类型常量的两种表示方法：
     1.十进制数形式：    3.14    314.0   0.314
     2.科学计数法形式:   3.14e0  3.14E2  3.14E-1
*/
  public static void testFloatNumber() {        //case 4：@浮点型测试testFloatNumber
      double d1 = 3.14;
      double d2 = 3.14E2;   //科学计数法
      System.out.println("3.14e2即3.14*10²="+d2);
      float f1 = 1.65F;     //浮点常量的默认类型是double，改成float需要后面加f。
      //浮点数是不精确的，最好不要直接比较，如下
      float f2 = 0.1F;
      double d3 = 1.0/10;
      System.out.println("判断f2与d3是否相等，返回值："+(f2==d3));   //"="单用为赋值，双用为比较，判断两个值是否相等，返回true/false。
  }
  /*执行结果：
    @浮点型测试testFloatNumber：
    3.14e2即3.14*10²=314.0
    判断f2与d3是否相等，返回值：false
  */
  /*@char字符型与转义字符
   * 计算机表示现实文字需要提前制定好“文字”与“二进制”之间的对照关系。这种对照关系被称为：字符编码。
   * Unicode字符集里的UTF-8编码中，英文占一个字节，其他文字占两个字节，包括汉字在内的文字占三个字节，少数文字占四个字节
   * Java中字符串不是基本的数据类型，而是一个类。
   * Java语言允许使用转义字符'\'以将其后的字符转变为其它的含义
   * 反斜杠u表示后面是一个字符的Unicode编码(十六进制)
   * “\b”为退格(Backspace)对应Unicode值为“\u0008”；“\n”换行“\u000a”；“\r”回车“\u000d”；
   * “\t”制表符(Tab)；“\"”双引号“\u0022”；“\'”单引号“\u0027”；“\\”反斜杠“\u005c”
   * String类，其实是字符序列(char sequence)，本质是char字符组成的数组。
*/
  public static void testChar(){        //case 5：@字符型与转义字符测试testChar
      char c1 = 'a',c2 = '中',c3 = '\"';       //任意单个字符或转义字符与特定英文字母的组合，加单引号
      char c4 = '\u0061', c5 = 97 ,c6 = 'a'+1; //'\u0000~\uffff'(带单引号)或 直接加数字(0~65536)也可以，对于c6，由于1是以int类型出现的，所以计算提升为int，'a'+1转换为97+1,输出对应的字符b
      System.out.println("a="+c1+"；中="+c2+"；\\\"="+c3+"；\\u0061="+c4+"；97="+c5+"；'a'+1="+c6);
      System.out.println("输出a\\\"双引号b\\\"双引号\\'单引号c\\'单引号d\\\\反斜杠e\\b退格f\\t制表符g\\n换行h\\r回车i可得：" + "a\"b\"'c'd\\e\bf\tg\nh\ri");
  }
  /*执行结果：
    @字符型与转义字符测试testChar：
    a=a；中=中；\"="；\u0061=a；97=a；'a'+1=b
    输出a\"双引号b\"双引号\'单引号c\'单引号d\\反斜杠e\b退格f\t制表符g\n换行h\r回车i可得：a"b"'c'd\f	g
    i
  */
  /*@布尔型(boolean)
   * boolean类型有两个常量值，true 和 false，默认值是false。
   * 在内存中占一个字节或四个字节，不可以使用0或非0的整数替代true和false(与C/C++语言不同)。
   * 布尔型在实际开发中常在逻辑判断中被放在条件的位置上（用于充当条件）
*/
    public static void testBoolean(){       //case 6：@布尔型测试testBoolean
        boolean b1 = true;
        boolean b2 = false;

        if(b1){     //"if(b1==true){"和"if(b1){"效果相同，但是一旦写成"if(b1=true)"时会先将true赋给b1，导致b1一定为true。
            System.out.println("b1是true");
        }else{		//其他情况(b1不为true时)
            System.out.println("b1是false");
        }
    }
  /*执行结果：
    @布尔型测试testBoolean：
    b1是true
  */
  /*@运算符(operator)
   * 算术运算符：二元(+、-、*、/、%（取模/取余）);一元/目(++、--)
   * 赋值运算符：基本赋值运算符(=);扩展赋值运算符(+=、-=、*=、/=、%=、&=、^=、|=、<<=、>>=)
   * 关系运算符：>、>=、<、<=、==(等于)、!=(不等于)
   * 逻辑运算符：&(逻辑与)、|(逻辑或)、!(逻辑非)、^(逻辑异或)、&&(短路与)、||(短路或)
   * 位运算符(直接操作二进制码)：&(按位与)、|(按位或)、^(按位异或)、~(按位取反)、<<(左移)、>>(右移)、>>>(无符号右移)
   * 条件运算符：布尔表达式 ? 表达式1 : 表达式2（三目/元）
   * 字符串连接符：+
   * 其他运算符：instanceof(判断某一个对象是不是某一个类)、new
   PS：赋值和关系运算符在使用过程中如果有两个符号的话，两个符号之间不能有空格，例如：==（正确）= =（错误）。
*/
    public static void testOperator() {     //case 7：@运算符测试testOperator
	//@算术运算符
        double d = 32 / 3;      //两个整数相除，默认的数据类型为int，结果也为int类型，则结果直接舍弃小数部分只留下整数，注意：没有四舍五入，即使将结果转为浮点型的数据类型，舍去的小数部分也不会回来，需要将表达式提升到浮点型的数据类型。
        double d2 = 32.0 / 3;   //这意味你需要先将计算结果数据类型转为double，再以double的数据类型赋给变量。
        System.out.println("赋值和算数运算符测试：\n32/3=" + d + "；32.0/3=" + d2);
        int e = -10 % 3;
        int e2 = 10 % -3;      //取余操作中，结果符号和左边操作数相同
        System.out.println("-10%3=" + e + "；10%-3=" + e2);
        int a = 10, b = a++, a2 = 10, b2 = ++a2; //a++/--与++/--a的不同之处：当变量自增或自减赋予另一个变量时，a++/--先赋a值给b，只有等到所在语句执行完毕后，a才会自增或自减；++/--a先自增或自减，再赋自增自减后的值给另一个变量。
        System.out.println("a=a2=10,b=a++,b2=--a\na=" + a + ";此时b=" + b + ";由结果可知b没有因a的自增而改变\na2=" + a2 + ";b2=" + b2 + "由结果可知a2在自增之后才将值赋给b2");
		int a3 = 10, a4 = 10, b3 = a3 + a3++, b4 = a4 + ++a4;	//a+++a会由于优先级转而进行等同于a+(++a)的操作而非(a++)+a
		System.out.println("a++/--的特性测试(a3=a4=10)：\nb3 = a3 + a3++ = 10+10;a3++ = "+b3+"；此时a3=11\nb4 = a4 + ++a4 = 10 + 11(a4(a4=10+1但不会影响前面已在运算中确定的a4(10)的字面值) = "+b4+"；此时a4="+a4);		//这里以自增为例，自减机制相同，不多赘述。
		System.out.print("\n打印的隐形赋值测试：\n此时：a="+a+" System.out.print(a++)："+(a++)+" 执行后：a="+a+"\n此时：a="+a+" System.out.print(++a)："+(++a)+" 执行后：a="+a);	//传，这个“传”在这里有一个隐形的赋值运算。
		/*大致可以拆解为：
			int temp = a++;		//先将打印内容赋给变量，这样形成了自增自减类似于上面由于位置不同造成输出结果不同的情况。
			// 对比：上面输出结果为10，a自增为11；下面输出结果为11，a自增为11
			int temp = ++a;
			System.out.println(temp);		//最后再将打印内容交给操作系统进行打印。
		*/
	//@关系运算符
		//关系运算符用来进行比较运算,关系运算的结果是布尔值：true/false
		
		//只有“==”、“!=”是所有（基本和引用）数据类型都可以使用，其他仅针对数值类型。
        char x = 'a';
        boolean y = x > 100;
        System.out.println("\n关系运算符测试：\n∵x='a',(int)x=97∴变量x的值不大于100，返回布尔型数值至y=" + y + ";(int)x =" + (int) x);  //char值位于0~65536之间，可以通过(int)强制转型成数字。
	//@逻辑运算符
		//与"&";短路与"&&"，只要两边都为true，结果才为true，可以理解为“并且”；或"|";短路或"||",只要有一个为true，则结果为true，可以理解为“或者”；非"!"取相反;异或"^"相同为false，不同为true;
		//短路与和短路或采用短路的方法。从左到右计算，只要遇到能够决定结果的操作数，就直接返回结果，不再判断与执行后面的代码，提高效率，抛开这一点，&&和||对于结果为true还是为false，与或和短路与或并无差异。
        boolean tr = true, fa = false;
        System.out.println("\n逻辑运算符测试(tr=true,fa=false)：\n与(&)：\ntr&fa=" + (tr & fa) + "\n或(|):\ntr|fa=" + (tr | fa) + "\n非(!)：\n!tr=" + (!tr) + "\n异或(^)：\ntr^fa=" + (tr ^ fa));
		System.out.println("此时：a="+a+" (fa && 10 < a++)："+(fa && 10 < a++)+" 执行后：a="+a);		//由于短路与的存在，当结果已经确定时，不再执行后面的代码，直接返回结果，所以后面的a自增不会被执行。
		System.out.println(" !(0/3 == 0 || 3/0 == 0)"+ !(0/3 == 0 || 3/0 == 0));		//首先 0不能做除数，3/0理论上会报错，但由于短路或的存在，所以右边的代码会跳过执行，则编译过程中不会检查出语法错误；其次逻辑非的优先级要大于与或，逻辑计算时会先执行逻辑非的取反操作，因此在混合使用时需要根据需求加括号。
	//@赋值运算符
        byte c = 3;int f = 4;
        c += f;     //相似于：c = c+f，但扩展赋值运算符永远不会改变运算结果的数据类型，因此，c += f等同于c = (byte)(c+f)。
        System.out.println("\n赋值运算符测试(c=3,f=4)：\n(c += f) ≈ (c= c+f) =" + c);
        c = 3;
        c *= f + 3;   //相似于：c = c*(f+3)；等同于：c = (byte)(c*(f+3))，右边(f+3)被视作一个整体
        System.out.println("(c *= f+3) ≈ (c= c*(f+3)) = "+ c);
		c = 3; f = 4;
		//c = c + f		错误：不兼容的类型：从int转换到byte可能会有损失，由于结果上升为int类型且编译器无法读取该字面值，尽管结果没有超出byte类型也无法编译通过。
		System.out.println("(c += f) = "+(c += f)+"；此时(c += f) 不等于(c = c+f)；但等同于(c = (byte)(c+f)");		//扩展运算符永远不会改变运算结果的数据类型，因此可以通过编译。
	//@条件运算符
        /*声明格式：type variable = (expression) ? value if true : value if false;   expression为表达式
					数据类型 变量名 = 布尔表达式 ? 表达式1 : 表达式2;
		  执行原理：布尔表达式的结果为true时，将表达式1的执行结果赋给变量
					布尔表达式的结果为false时，将表达式2的执行结果赋给变量
		  PS：被赋值变量的数据类型要和表达式1与表达式2结果的数据类型相兼容。*/
        int score = 90;
        String level = score < 60 ? "不及格" : (score == 60 ? "及格" : "优");
        System.out.println("\n条件(三元)运算测试(60分及格，60以上优)：\n输入分数90分，∵90不小于60∴返回false对应的变量(score==60?\"及格\":\"优\")又∵90不等于60∴返回false对应的变量至level="+ level +"\nSystem.out.println的特殊性测试：");
		System.out.println("score >= 90 ? '优':\"继续努力\"："+(score >= 90 ? '优':"继续努力"));		//值得一提的是：println()是PrintStream类的单个方法，PrintStream约有10种不同的println()方法重载，这些重载根据用户传递的参数类型来调用，因此该方法能够接受不同类型和数量的参数来打印各种类型的元素。
    //@字符串连接符
        //"+"运算符两侧任一操作数为字符串(String)类型时，系统会自动将另一个操作数转换为字符串然后再进行连接。
        //注意：当一个表达式有多个加号时，遵循“从左向右”的顺序顺次执行（小括号的影响除外），这意味着如果左边的加号两边都是数字，那么该加号会进行求和而非字符串拼接。
		String s = "你好";	char c1 = 'h', c2 = 'i';	c = 3; f = 4;
        System.out.println("\n字符串连接符测试:\nc1+c2="+(c1 + c2));  //条件必须是String，即使是char也仍然是加法。
        System.out.println("\"\"+s+c1+c2="+(""+s+ c1 + c2 + c1 + c2));  //可以通过加空字符串或字符串变量的方法引发链式反应(双向的多米若骨牌)使得所有”+“都变成字符串连接符,不想改变的部分可以拿括号括起来。
		System.out.println("System.out.println(c + f + \"000\")："+(c + f + "000")+"；c + (f + \"000\")："+(c + (f + "000")));		//加号从左向右执行，两边为数字则求和，两边其中一边为字符串则进行字符串拼接，小括号可以影响加号的执行顺序
	//@位运算符
        //位运算指的是进行二进制位的运算。其中1相当于true，0相当于false，与逻辑运算相似，只不过是计算数字的二进制形式。
        //"~"取反，"&"按位与，"|"按位或，"^"按位异或，"<<"左移运算符，左移1位相当于乘2，">>"右移运算符，右移1位相当于除2取商，">>>"无符号右移赋值,向右移动指定数量的比特位，然后把结果赋给变量，可以理解为对某数的二进制从右向左删x位，从左向右补回x个0;
        int m0111 = 7, m1000 = 8;     //位运算是数字二进制形式的相同位数之间进行逻辑判断，如数字7二进制形式为111，数字8为1000，若两个数字按位与，先由万位与万位进行逻辑判断，不存在的位数取0，则7的万位0(false)和8的万位1(true)，与有一个false则结果为false，则结果二进制形式的万位为0，其余位数以此类推。
        System.out.println("\n位运算测试(m0111=7=0b0111;m1000=8=0b1000)：\n按位与(&)：\nm0111&m1000=" + (m0111 & m1000) + "\n按位或(|)：\nm0111|m1000=" + (m0111 | m1000) + "\n按位异或(^)：\nm0111^m1000=" + (m0111 ^ m1000) + "\n取反(~)：\n~m1000=" + (~m1000));
        System.out.println("\n移位运算测试(10=0b1010):\n左移(<<)：\n5<<2=5*2*2" + (5 << 2) + "\n右移(>>)：\n40<<3=40/(2*2*2)=40/8=" + (40 << 3) + "\n无符号右移(>>>)：\n10>>>2=0b1010>>>2=0b(将00添到最左边1010删去最右边10)=0b0010=" + (10 >>> 2));       //乘以2或除以2，使用移位操作最快！
  /*@运算符优先级：(主要：括号最高，算术高于关系，关系运算符比位运算符和逻辑运算符高，逻辑非(!)>逻辑与(&)>逻辑或(|))
        1.“()”括号运算符
        2.“!”、“+(正号)”、“-(负号)”一元运算符，“~”位逻辑运算符，“++”、“--”递增与递减运算符
        3.“*”、“/”、“%”算术运算符
        4.“+”、“-”算术运算符
        5.“<<”、“>>”位左移、右移运算符
        6.“>”、“>=”、“<”、“<=”关系运算符
        7.“==”、“!=”关系运算符
        8.“&”位运算符、逻辑运算符
        9.“^”位运算符、逻辑运算符
        10.“|”位运算符、逻辑运算符
        11.“&&”逻辑运算符
        12.“||”逻辑运算符
        13.“?:”条件运算符
        14.“=”、“+=”、“-=”、“*=”、“/=”、“%=”赋值运算符、扩展运算符	*/
    //@逻辑运算符优先级问题：
        System.out.println("\n逻辑运算符优先级问题测试：\n!tr||tr&&fa) = (!tr)||(tr&&fa) = false||false = " + (!tr || tr && fa)); //逻辑运算符：非>与>或
	}
  /*执行结果：
    @运算符测试testOperator：
	  赋值运算符测试：
		32/3=10.0；32.0/3=10.666666666666666
		-10%3=-1；10%-3=1
		a=a2=10,b=a++,b2=--a
		a=11;b=10;由结果可知b没有因a的自增而改变
		a2=11;b2=11由结果可知a2在自增之后才将值赋给b2

	  a++/--的特性测试(a3=a4=10)：
		b3 = a3 + a3++ = 10+10;a3++ = 20；此时a3=11
		b4 = a4 + ++a4 = 10 + 11(a4(a4=10+1但不会影响前面已在运算中确定的a4(10)的字面值) = 21；此时a4=11

	  打印的隐形赋值测试：
		此时：a=11 System.out.print(a++)：11 执行后：a=12
		此时：a=12 System.out.print(++a)：13 执行后：a=13
		关系运算符测试：
		∵x='a',(int)x=97∴变量x的值不大于100，返回布尔型数值至y=false;(int)x =97

	  逻辑运算符测试(tr=true,fa=false)：
		与(&)：
		tr&fa=false
		或(|):
		tr|fa=true
		非(!)：
		!tr=false
		异或(^)：
		tr^fa=true
		此时：a=13 (fa && 10 < a++)：false 执行后：a=13
		 !(0/3 == 0 || 3/0 == 0)false

	  赋值运算符测试(c=3,f=4)：
		(c += f) ≈ (c= c+f) =7
		(c *= f+3) ≈ (c= c*(f+3)) = 21
		(c += f) = 7；此时(c += f) 不等于(c = c+f)；但等同于(c = (byte)(c+f)

	  条件(三元)运算测试(60分及格，60以上优)：
		输入分数90分，∵90不小于60∴返回false对应的变量(score==60?"及格":"优")又∵90不等于60∴返回false对应的变量至level=优
		System.out.println的特殊性测试：
		System.out.println(score >= 90 ? '优':"继续努力")：优

	  字符串连接符测试:
		c1+c2=209
		""+s+c1+c2=你好hihi
		c + f + "000"：7000；c + (f + \"000\")：34000

	  位运算测试(m0111=7=0b0111;m1000=8=0b1000)：
		按位与(&)：
		m0111&m1000=0
		按位或(|)：
		m0111|m1000=15
		按位异或(^)：
		m0111^m1000=15
		取反(~)：
		~m1000=-9

	  移位运算测试(10=0b1010):
		左移(<<)：
		5<<2=5*2*220
		右移(>>)：
		40<<3=40/(2*2*2)=40/8=320
		无符号右移(>>>)：
		10>>>2=0b1010>>>2=0b(将00添到最左边1010删去最右边10)=0b0010=2
		
	  逻辑运算符优先级问题测试：
		!tr||tr&&fa) = (!tr)||(tr&&fa) = false||false = false
  */
  /*@Scanner处理键盘输入
   * 创建 Scanner 对象的基本语法：
    Scanner 变量名 = new Scanner(System.in);
   * 可以使用next()与 nextLine()方法获取输入的字符串，它们两者区别如下
   * next()
    1、一定要读取到有效字符后才可以结束输入。
    2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。
    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
    因此next()不能得到带有空格的字符串。
   * nextLine()：
    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
    2、可以获得空白。
   * 在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：
   * 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取
*/
	public static void testKeyInput(){		//case 8:@Scanner接收用户键盘输入测试testKeyInput
		System.out.println("@Scanner接收用户键盘输入测试testKeyInput/n请输入任意字符");
		Scanner variableName = new Scanner(System.in);		//创建一个键盘扫描器对象，若不想在上面导入 java.util 包下的 Scanner 类，可改写为java.util.Scanner 变量名 = new java.uitl.Scanner(System.in);
		String str = variableName.next();	//程序执行到此处会停下来，直到用户输入内容回车后才会结束，且该变量用于接收输入的内容，因此该变量的数据类型决定了输入内容的数据类型。
		System.out.println("您输入的内容是："+str);
	}
  /*执行结果：
	@Scanner接收用户键盘输入测试testKeyInput
  	请输入任意字符[]
	您输入的内容是[]
  /* java控制语句
   1.控制语句包括：选择语句（分支语句）(if、switch)、循环语句(for、while、do...while)、转向语句(break、continue、return)
   2.“顺序结构”代表“先执行a，再执行b”的逻辑。比如：先电脑开机，再玩电脑游戏。
   3.“条件判断结构”代表“如果......，则......”的逻辑。比如：如果看到红灯，则停车。
   4.“循环结构”代表“如果......，则重复执行......”的逻辑。比如：如果实验没有成功，则继续进行实验。
*//*@条件判断结构：
   1.if结构（if单分支结构；if-else双分支结构；if-else if多分支结构）
   2.switch结构
  /*@if结构：
    * if(布尔表达式){
		//如果 布尔表达式 为true将执行的语句
    }else if(布尔表达式 2){
		//如果 布尔表达式 2 的值为true将执行的语句
    }else{
    //如果 以上 布尔表达式 都不为true 将执行的语句
    * 如果if语句不写{}，则只能作用于后面的第一条语句，跟else/else if也只能在第一行代码之后。。
*/
  public static void testIf(){      //case 9：@If语句测试testIf
      int a = (int)(Math.random()*6)+1;
      int b = (int)(Math.random()*6)+1;
      int c = (int)(Math.random()*6)+1;
      int sum = a+b+c;
      System.out.println("第一次掷骰子："+a);
      System.out.println("第二次掷骰子："+b);
      System.out.println("第三次掷骰子："+c);
      if(sum>15){
          if(sum==18){        //使用嵌套的if语句是合法的。
              System.out.println("运气封顶！去买彩票！");
          }else {
              System.out.println("手气不错！再来一把！");
          }
      }else if(sum>=10){
          System.out.println("手气一般！再来两把！");
      }else{
          System.out.println("手气不行！回家吧！");
      }
      System.out.println("今天得分="+sum);
  }
  /*执行结果：
    @If语句测试testIf：
    第一次掷骰子：a
    第二次掷骰子：b
    第三次掷骰子：c
    "运气封顶！去买彩票！"/"手气不错！再来一把！"/"手气一般！再来两把！"/"手气不行！回家吧！"
    今天得分=a+b+c
  */
  /*@switch多分支结构(多值情况)
   * switch从相匹配的case标签处开始执行，一直执行到break处或是switch的末尾。若表达式的值与任一case值不匹配，则进入default语句。
   * 语句语法格式：
   switch(expression){
    case value1 :
       语句块1;
       [break]; //[]可选
    case value2 :
       语句块2;
       [break];
       ...
    [default :
       默认语句块;
       break;]
    }
   * switch中表达式(expression)的值，可以是int,byte,short,char,枚举,字符串(JDK1.7之后，但使用String类型的同时case标签必须为字符串常量或字面量。)
   * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。
   * 注意一：如果default标签前的case标签没有break且被执行，则在该case标签下的语句块执行完后，还会执行包括default在内的以下所有标签下的语句块直至遇到break或者执行到结尾。
   * 注意二：如果default标签被写在了switch语句的开头或中间，且default的语句块中没有break以跳出switch，那么当表达式的值与任一case值不匹配，进入default语句时，执行完default语句后还会执行下面的case直至遇到break或者执行到结尾。
*/
  public static void testSwitch(){      //case 10：@Switch多分支结构测试(与if对比)testSwitch
      int month = (int)(Math.random()*12)+1;    //(int)Math.random()*x;     即为生成0~(x-1)的随机数(具体过程为生成大于或等于0且小于1的浮点数*x再强制转为int类型，即舍弃小数部分，没有四舍五入，所以是0~(x-1)，我们可以用(int)Math.random()*(最大数-最小数+1)+最小数，来表示随机生成最大数与最小数之间的包括它们在内的整数)
      System.out.println("测试一：随机一个月份并判断归属于上半年还是下半年\n本次随机数为="+month);
      switch (month){
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
              System.out.println("switch版本："+month+"月，属于上半年");
              break;        //如果default标签前的case标签没有break且被执行，则在该case标签下的语句块执行完后，还会执行包括default在内的以下所有标签下的语句块直至遇到break或者执行到结尾。
          default:
              System.out.println("switch版本："+month+"月，属于下半年");
          case 13:
              System.out.println("若default的语句块中没有break以跳出switch，进入default语句时，执行完default语句后还会执行下面的case直至遇到break或者执行到结尾。");
      }
      if(month<7) {          //if版本，效果同上。
          System.out.println("if版本："+month+"月，属于上半年");
      }else{
          System.out.println("if版本："+month+"月，属于下半年");
      }
      String life = "动物";
      System.out.print("String类型测试：");
      switch (life){        //String类型测试(JDK1.7之后)
          case "动物":
              System.out.println("动物，你好！");
              break;
          case "植物":
              System.out.println("植物，你好！");
              break;
          default:
              System.out.println("外星生命体，你好！");
              break;
      }
	  System.out.println("测试二：用户输入一个成绩并判断等级\n请输入要查询等级的成绩(int类型的数据)");		//总分100分，小于60为D，等于60分小于75为C，小于85为B，大于等于85为A，满分A+
	  Scanner s = new Scanner(System.in);
	  double score = s.nextDouble();
	  if (score>=0 && score<=100)
	  {
		  int grade = (int)(score/5);		//将输入的内容除以5以减少case的数量，并强转为int类型解决小数问题。
		  String str = "?";
		  switch(grade){
		  case 20:
			  str = "A+";
			  break;
		  case 19: case 18: case 17:
			  str = "A";
			  break;
		  case 16: case 15:
			  str = "B";
			  break;
		  case 14: case 13: case 12:
			  str = "C";
			  break;
		  default:
			  str = "D";
			  break;
		  }
		  System.out.println("该成绩的等级为"+str);
	  }else{
		  System.out.println("错误的成绩");
	  }
  }
  /*执行结果：
    @Switch多分支结构测试(与if对比)testSwitch：
	测试一：随机一个月份并判断归属于上半年还是下半年
    本次随机数为=month
    switch版本：month月，属于上/下半年
    if版本：month月，属于上/下半年
    String类型测试：动物，你好！
	测试二：用户输入一个成绩并判断等级
	请输入要查询等级的成绩
	[0~100]else[错误的成绩]else[error]
	[D](<60) [C](>=60&<75) [B](>=75&<85) [A](>=85&<100) [A+](100)
  */
  /*@循环结构
   * 当型循环结构：当布尔表达式条件为true时，反复执行某语句，当布尔表达式的值为false时才停止循环，例如：while与for循环。
   * 直到型循环结构：语句块在检测布尔表达式之前先执行，如果布尔表达式的值为true，则语句块一直执行，直到布尔表达式的值为false，例如do-while循环。
   @循环结构while
	* 语法结构：
	  while(布尔表达式){
          循环体;
      }
	* 执行原理：
	  判断布尔表达式的结果，如果为true则执行循环体，循环体结束之后再次判断布尔表达式，重复之前操作，直至布尔表达式的结果为false，while循环结束。
  *///while循环测试
  public static void testWhile(){       //case 11：@循环结构测试testLoops的分支一testWhile()
      System.out.println("\n循环结构while测试：");
      //累加：0+1+2+3+...+100
      int i = 0,count = 0;
      int sum = 0;
      while(i<=100){
          sum = sum + i;
          i++;
          count++;      //计数器，每循环一次加一
          if(count%20==0){      //每当循环次数能被20整除时
              System.out.print("当循环次数为"+count+"时，此时i的值为"+i+"；sum(和)的值为"+sum+"\n");
          }
      }
      System.out.println("循环结束，从1累加到100的和："+sum);
    /*@循环结构do-while
	  语法结构：
		do {
			循环体;
		}while(布尔表达式);
	   执行原理：
	   	 先执行循环体当中的代码，执行一次循环体之后再判断布尔表达式的结果，
		 如果为ture，则继续执行循环体并判断布尔值类型，如果为false循环结束。
		对于do-while循环来说，循环体至少执行一次
	*///do-while循环测试
      do{
          System.out.println("do-while循环结构中语句块的执行会放在检测布尔表达式之前，这意味着无论布尔表达式结果如何，语句块都会先执行一次");
      }while(false);
  }
  /*执行结果：
    循环结构while测试：
    当循环次数为20时，此时i的值为20；sum(和)的值为190
    当循环次数为40时，此时i的值为40；sum(和)的值为780
    当循环次数为60时，此时i的值为60；sum(和)的值为1770
    当循环次数为80时，此时i的值为80；sum(和)的值为3160
    当循环次数为100时，此时i的值为100；sum(和)的值为4950
    循环结束，从1累加到100的和：5050
    do-while循环结构中语句块的执行会放在检测布尔表达式之前，这意味着无论布尔表达式结果如何，语句块都会先执行一次
  */
  /*@循环结构for
   * 初始化部分(循环变量的初值)；条件判断部分(布尔表达式)；迭代因子(控制环境变量的增减，又名更新表达式，迭代因子可以写在循环体的最后，这样for()内迭代因子可以省略不写)
   * 初始化步骤可以声明一种类型，且能初始化一个或多个循环控制变量，也可以是空语句，但需要以分号结尾（初始化部分声明的新变量属于for循环的局部变量，for循环结束后该变量的内存就会被释放）。
   * 
   * 总执行顺序：
		先执行初始化表达式(无论循环多少次，该部分只执行一次)，然后检测布尔表达式的值，如果为true，则先执行循环体，再执行迭代因子（更新表达式）
		迭代因子执行完后再判断条件表达式的结果，如果为true，继续执行循环体，迭代因子，再判断......直至检测布尔表达式的值为flase，循环终止，开始执行循环外部的语句。
   * 若循环体只有一条语句时,大括号{}可以省略
   * 语法结构：
     for(初始表达式;布尔表达式;迭代因子){
          循环体;		//循环体由java语句构成
     }
   * @增强for循环
   * 语法结构：
    for(元素类型 变量名 : 数组或集合对象) {
    }
  */
  public static void testFor(){     //case 11：@循环结构测试testLoops的分支二testFor()
      //for循环类型测试：计算100之内的累加和、奇数和、偶数和
      int sum=0,oddSum=0,evenSum=0;
        for (int i=0;i<=100;i++){
            sum += i;        //sum = sum+i
            if(i%2==0){      //判断是否能被2整除
                evenSum += i;       //如果能(偶数)
            }else{
                oddSum += i;        //如果不能(奇数)
            }
        }
      System.out.println("\n循环结构for测试：");
      System.out.println("100之内数字的累加和："+sum);
      System.out.println("100之内所有奇数的和："+oddSum);
      System.out.println("100之内所有偶数的和："+evenSum);
      //加强for循环测试
      int[] g = {1,2,3};
      for(int a:g){
          System.out.print("\n加强for循环测试："+a);    //增强for内部会依次把g中的元素赋给变量a
      }
  }
  /*执行结果：
    循环结构for测试：
    100之内数字的累加和：5050
    100之内所有奇数的和：2500
    100之内所有偶数的和：2550

    加强for循环测试：1
    加强for循环测试：2
    加强for循环测试：3
*//*@嵌套循环
  * 循环语句内部加入循环即为嵌套循环。两层最常见
*/
  public static void testloop2(){       //case 11@循环结构测试testLoops的分支三testloop2()
      //打印9*9乘法表
      System.out.println("\n\n嵌套循环测试一：（9*9乘法表）");
      for(int m = 1; m <= 9; m++){
          for(int n=1;n<=m;n++){
              System.out.print(m+"*"+n+"="+(m*n<10?(" "+m*n):m*n)+"\t");
              }
          System.out.println();
      }
      //交替打印"*"和"#"
      System.out.println("\n嵌套循环测试二：（交替打印\"*\"和\"#\"）");
      for(int q = 1; q <= 3; q++){
          for(int i=0;i<5;i++){
              if((q+i)%2==1){       //判断 行数 与 当前行个数 的和能否被2余下1（如第一行第一个和为1(1+0)，被2除余1，打印"*",第二行第一个和为2(2+0),被2除余0打印"#"）。
                  System.out.print("*\t");
              }else{
                  System.out.print("#\t");
              }
          }
          System.out.println();
      }
	  //求1000以内的所有完数(一个数等于它的因子之和，如6 = 1+2+3)
     System.out.println("\n嵌套循环测试三：（求1000以内的所有完数）/n1000以内所有完数：");
	  for(int x = 2; x <= 1000; x++){		//0与1都不是完数
		  int sum = 0;
		  for(int y = 1; y <= x/2; y++){	//没有一个数的因子大于它的一半且小于他本身的情况
			if(x % y == 0){
			  sum += y;
			  }
			}
			if (x==sum){
				System.out.print("/t"+x);
			}
		  }
  }
  /*执行结果：
    嵌套循环测试一：（9*9乘法表）
    1*1= 1
    2*1= 2	2*2= 4
    3*1= 3	3*2= 6	3*3= 9
    4*1= 4	4*2= 8	4*3=12	4*4=16
    5*1= 5	5*2=10	5*3=15	5*4=20	5*5=25
    6*1= 6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36
    7*1= 7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49
    8*1= 8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64
    9*1= 9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81

    嵌套循环测试二：（交替打印"*"和"#"）
    *	#	*	#	*
    #	*	#	*	#
    *	#	*	#	*
*//*@break和continue语句以及带标签的break和continue语句
   * break：强行退出整个离它最近的循环
   * continue：结束本次循环，进行下一次循环
   * 带标签的break(break label) ：跳出给定label的代码块
   * 带标签的continue(continue label)：终止本次循环，跳转到标签位置进行接下来的循环
*/
  public static void testBreakAndContinue(){        //case 12：@break和continue语句以及带标签的break和continue语句测试testBreakAndContinue
      //测试break：（循环打印70~89的随机数直至出现88，每10个数换一行,，最多循环20次）
      System.out.println("\nbreak语句测试：");
      int total = 0;
      while (true){       //一个无限循环，只能由break跳出
          total++;
          int j =(int)(Math.random()*20+70);
          if(total==20) {
              System.out.print(j+" ");
              break;      //循环次数达到20，跳出当前循环，当前循环下的语句块都不会执行。
          }else if(total % 10 == 0) {
              System.out.println(j+" ");
          }else{
              System.out.print(j+" ");
          }
          if (j == 88) {
              break;      //如果当前生成的随机数为88，则跳出当前循环，跳出后当前循环中该break下的语句都不会执行。
          }
      }
      System.out.println("\n循环次数："+total);
      //测试continue语句：（打印100~150不能被3整除的数，每行输出5个）
      System.out.println("\ncontinue语句测试：");
      int counter = 0;      //计数器
      for(int i=100;i<=150;i++){
          if(i%3==0){
              continue;
          }
          System.out.print(i+" ");
          counter++;
          if(counter==5){       //不想用还原可以判断能否被5整除
              System.out.println();
              counter=0;        //计数器还原方法
          }
      }
      //测试带标签的break和continue语句：（循环打印80~89，直到连续的两个随机数都是88，每20个换一行）
      System.out.println("\n\n带标签的break和continue语句测试：");
      int count = 0;
      label:while (true){       //label为标签，其名称可自定义
          count++;
          int i =(int)(Math.random()*10+80);
          if(count%20==0){
              System.out.println(i+" ");
          }else{
              System.out.print(i+" ");
          }
          if(i==88){
              for(int j=(int)(Math.random()*10+80);j==88;){
                  count++;
                  if(count%20==0){
                      System.out.println(j+" ");
                  }else{
                      System.out.print(j+" ");
                  }
                  if(j==88){
                      break label;      //如果i和j都为88，
                  }else{
                      continue label;
                  }
              }
          }
      }
      System.out.println("\n循环次数："+(count-1));
  }
  //执行结果略
  /*@方法(method)(同C语言 函数)
   * 方法是可以完成某个特定功能的并且可以被重复利用的代码片段，它可以使程序变得更简短而清晰，提高程序开发的效率和代码的重用性。
   * 方法内部的代码也是遵守自上而下的顺序顺次执行的。
   * 注意：方法中的局部变量会在方法结束之后释放占用的内存，因此并列的方法无法直接互相调用变量。
   * 定义一个方法的语法：（参数可以有多个）
     [修饰符列表] 返回值类型 方法名(参数类型 参数名){       //“参数类型 参数名”为形式参数(在方法声明时用于接收外界传入的数据)；方法名首小写后每词首字母大写，详见标识符。
         Java 语句;... ... ...
     return 返回值;		//返回值类型为void可以不写该语句，若要写的话直接写“return;”以结束该方法。
     }
   * 关于返回值类型：
   	 1.返回值类型可以是任何类型，只要是java中合法的数据类型就行。
	 2.返回值一般是指方法执行结束之后的结果，由于结果通常是一个数据，所以被称为“值”(返回值)，方法结束之后大部分是有一个结果的，体现结果的一般是数据，数据需要声明数据类型，这里即返回值类型。
	 3.当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字，所以void表示该方法执行结束后不返回任何结果。
	 4.如果返回值类型不是void，那么在方法体执行结束前必须使用“return 值;”来完成“值”的返回，即返回方法的执行结果，且return关键字的语句一旦被执行，当前方法就会结束。非void返回值类型的方法中没有retur返回值则无法通过编译器(return语句被写在控制语句的分支中，有不被执行的风险也无法通过编译器，除非保证在每条分支下都有return以返回方法结果)。
	 5.return返回的值并非仅限于单个变量，只要返回的值符合该方法的返回值类型即可，如String返回值类型方法中编写return "值为：" + var;	//var假设变量名
   * 形式参数列表（简称：形参）：
   	 * 形参列表中的每一个参数都是 局部变量 ，方法结束后会释放其内存（如：方法1调用方法2(形参i)并传入值i，在方法2中重新对i赋值不会影响到方法i中i变量的值。这也侧面反映了不同作用域中局部变量相互独立，与名称无关）。
	 * 形参的个数是0~N个，多个形参用英文逗号隔开，形参的数据类型起决定性作用，形参对用的变量名是随意的(命名规范详见标识符)，如：public static void methodTest(int a, char b, double d, String e){}
   * 方法的调用程序：(main方法不需要手动调用，是由JVM调用的，除了main方法之外的其他方法都需要程序员手动调用)
     * 普通方法：对象名.方法名(实参列表)       //调用方法时赋的值为实参(调用方法时实际传给方法的数据)
     * 静态方法：类名.方法名(实参列表)		//调用同一个类中的静态方法的类名部分可以省略。
	 * PS：
		1.调用时传的实参与形参数据类型和个数必须一一对应，传的实参为变量时会复制该变量的值传到方法内。
		2.调用方法的程序不一定要写到main方法，可以在其他方法中调用另一个方法，且由于顺次执行的原则，在方法中调用方法程序以下的代码需要等到被调用的方法执行结束才有执行的可能。
		3.可以使用变量来接收方法的返回值，但变量的数据类型必须与方法的返回值数据类型相兼容，如：int result = JavaEveryday.testMethod
		4.方法在调用的瞬间，会给该方法分配内存空间，会在栈中发生压栈动作，方法执行结束乏后；给该方法分配的内存空间全部释放，此时发生弹栈动作。
   * 语句块（复合语句）
     * 使用方法：开括号“｛”开始，闭括号“｝”结束
     * 语句块中定义的变量只能用于自己，外部不能使用。语句块可以使用外部的变量，而外部不能使用语句块的变量，且语句块内的变量不能与外部变量重名，但是并列的语句块可以重名，但嵌套的语句块不能。
*///测试方法语句与语句块的使用(打印大于给定整数的最小质数)		//调用见下面FirstPart目录下case 13部分
  public static int testMethod(int g) {        //case 13：@方法(method)语句测试testMethod
	  boolean flag = true;
	  int n = g+1;
	  for(;!primalityTesting(n);n++){}	//方法的调用程序可以以其结果数据的形式书写(此处进行了逻辑非运算"!")，每次使用都会先执行一遍方法，然后再取结果的数值来代替方法调用程序所在的位置。
	  System.out.println("大于"+g+"的最小质数为："+n);		//方法的执行程序也可以直接放在System.out.println();等括号内需要一个自己定义或系统要求字面量（且其数据类型能够与被存放方法返回值类型相兼容）的位置(类似于用变量名代替字面量)，且会先执行方法，然后打印结果（如只执行方法不会打印结果）。（详见调用部分FirstPart下case13）
	  return n;
  }
  //定义一个专门的方法来判断数字是否为质数（形参：num ；返回值类型：bealoon）
  public static boolean primalityTesting(int num){
	  for(int i = 2; i <= num/2; i++){
		  if(num % i == 0){		//质数只能被1和自身整除，若能被其他数整除，则进入if的true分支，返回布尔值false；循环中的每个数都不能把sum整除，则跳过if语句执行下方代码（返回值true）
			  return false;
		  }
	  }
      return true;       //return两个作用：1.返回值；2.结束方法运行
  }
  /*执行结果：
    @方法(method)语句测试testMethod：
	大于10的最小质数为：13
	第一次调用(赋值g=10)：
	13

	第二次调用(赋值g=11)：
	大于11的最小质数为：13
	13
  */
  /*@方法的重载(overload)
   * 重载：一个类中可以定义多个名称相同，但形式参数列表不同的方法。
   * 构成条件：
     1.不同的含义：形参类型、形参个数、形参顺序不同
     2.只有返回值不同不构成方法的重载
     3.PS：
		* 只有形参的名称不同，不构成方法的重载
		* 跨类的方法间不构成方法的重载
   * java编译器再区分方法时首先通过方法名，在方法重载的情况下(方法名相同)会通过形参类型和个数来进行方法的区分。
	 因此在调用时只需要传对应方法形参类型与个数的实参，就可以通过重载来实现方法对不同参数类型自动区分和处理。
   * println()方法就是一个很好的方法重载例子。另外，可以通过提前编译class字节码文件放在需调用的源文件同目录下或写其他的类在需调用的源文件内，来实现对代码的封装，即通过"类名.方法名()"来调用主文件主类外的方法（代码）。(同一文件夹内，源代码可以调用任何class文件)
*/
    static void add(int a){}
    static void add(double a){}
    static void add(int a,double b){}
    static void add(double b,int a){}
  /*递归结构(recursion)
   * 定义递归头：递归的结束条件
   * 递归体：调用自身方法的条件
   * 递归没有结束条件(一直执行压栈动作)的时候会发生栈内存溢出错误(StackOverflowError)，因此递归必须要有结束条件，没有结束条件一定会栈内存溢出，但有结束条件也不能保证栈内存不溢出，此时就需要手动调整JVM的栈内存初始化大小。
   * 递归耗费内存比较大，且不稳定，使用不当会导致JVM死掉，在实际开发中尽量用循环代替，效率更高，耗费内存也更少。（但递归的存在是实现部分程序所必须的）
*///递归测试：（阶乘计算）
  public static void testrecursion(){        //case 14：@递归(recursion)结构测试testrecursion
      long startTime = System.currentTimeMillis();      //获取当前时间，并赋值给endTime（与递归无关，仅用来计算递归耗时，下同）
      long result = factorial(5);       //算法简单是递归的优点之一，但递归回占用大量的系统堆栈，内存耗用大，在递归调用层数多时的速度要比循环慢得多，所以使用递归前要慎重考虑。
      long endTime = System.currentTimeMillis();        //获取当前时间，并赋值给endTime，不过是在递归结束后
      System.out.println("递归结果=n*(n-1)*(n-2)......(n-x)="+result+"\n递归耗时："+(endTime-startTime));
  }
  public static long factorial(int n){
      if(n==1){
          return 1;
      }else{
          return n*factorial(n-1);  //如果n不为1则将此时的n*recursion的返回值返回到recursion，乘法运算中的recursion被传参n-1。递归最终返回值为n*(n-1)*(n-2)......(n-x)
      }
  }
  /*执行结果：
    @递归(recursion)结构测试testrecursion：
    递归结果=n*(n-1)*(n-2)......(n-x)=120
    递归耗时：0
*//*------------第二篇章：对象与类与内存分析------------
   *@面向过程与面向对象的共同点与区别：
    * C语言完全面向过程；C++半面向过程半面向对象；Java完全面向过程
    * 共同点：
     * 面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导人们以不同的方式去分析、设计和开发软件。
     * 面向过程与面向对象相辅相成。
    * 区别：
     * 面向过程编程(procedure oriented Programming)(POP)适合简单、不需要协作的事务，重点关注如何执行。面向过程时，我们首先思考”怎么按步骤实现？“并按步骤对应成方法，一步一步，最终完成。（执行者思维）
     * 面向对象编程(Object Oriented Programming)(OOP)思想更契合人的思维方式。我们首先思考的是”怎么设计这个事务？“面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。但具体到一个个方法，仍需要面向过程的思路去处理。（设计者思维）
    * 优缺点：
	 * 面向过程
	  优：开发小型项目效率较高，不需要提取对象，建立模型等准备工作，可以直接写代码，编写因果关系实现功能。
	  缺：面向过程主要是步与步、模块与模块间的因果关系，若其中一个因果关系出问题，会导致整个系统瘫痪。(代码与代码之间的耦合度太高，扩展力太差)
	 * 面向对象
	  优：耦合度低，扩展能力强。
	* 面向对象是一种“设计者思维”。设计时，先从问题中找名词，然后确立这些名称哪些可以作为类，再根据问题需求确定类的属性和方法，确定类之间的关系。
    * 当我们采用面向对象的方法贯穿整个系统时，一般包括(OOAO/OD/OOP)
	 1.OOA：面向对象分析(Object-Oriented Analysis)
	 2.OOD：面向对象设计(Object-Oriented Design)
	 3.OOP：面向对象编程(Object Oriented Programming)
	* 面向对象的三大特征：(详细见下)
	 1.封装 (Encapsulation)
	 2.继承 (Inheritance)
	 3.多态 (Polymorphism)
	* 类：class；对象：Object,instance(实例)。某个类的对象，某个类的实例，是一个意思，对象=实例。
    * 类与对象的概念和关系
	 * 类实际上在现实中是不存在的，是一个抽象的概念，可以把它看作是一类对象的模板或图纸，类描述的是同一类型的对象的共同特征信息，类中定义了这一类对象所应具有的共同的属性、方法。
	 * 对象则是实际存在的个体，可以将其看作该类的一个具体实例。
	* 对象是通过类这个模板创造出来的，通过类型创建对象的过程我们称之为：创建/实例化；由多个具有相同特征的对象，进行思考总结抽取共同特征为类的过程被称为：抽象。
    * 方法(method)：方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
*//*@简单内存分析（理解面向对象）（文本图像见配套图片文件或阅读版）
	 * 内存中包含：栈(stack)、堆(heep)、方法区(method area)
      * 简单认识：栈(stack)存放 执行的方法(方法执行时会在其中开辟一个栈帧)；堆(heep)存放 建好的对象；方法区(method area)存放 每个类的信息(包括每个类的方法，包含属性的常量池，static属性和方法)（方法区本质上也是堆，类信息的内部仍是按一个个对象存储的）
      * 栈数据结构(stack)：
	   * 数据结构：存储数据的容器	//容器可能存在不同的结构
	   * 数据结构：数组、链表、图、二叉树、栈(先进后出，后进先出)、队列(先进先出)......
	   * 和数据结构通常一起出现的：算法(排序算法、查找算法、......算法)
	   * 数据进栈的过程又称入栈、压栈、push；数据出栈的过程又称弹栈pop；栈底元素(最先进，固定)，栈顶元素(最后进，浮动)，栈帧永远指向的是栈顶部的元素，且处于栈顶部的元素具备活跃权。（堆栈的最低地址叫栈首，不叫栈顶）
	/* JAVA虚拟机内存模型概念：
      1.一个程序启动会有多个线程，每个线程有独立的 方法计数器、虚拟机栈、本地方法栈。（注意：每个线程的栈独立，但共享一个堆heep和方法区method area）
      2.堆heep，分为新生代和老年代，用于垃圾回收。
      3.方法区method area，运行时常量池（类信息、常量）
      4.直接内存‘其他内存
     * Java虚拟机的内存可以分为三个方法区域：栈stack、堆heap、方法区method area。
      * 虚拟机栈（简称：栈）的特点：
       1.栈描述的是方法执行的内存模型。每个方法被调用时都会创建一个栈帧（存储局部变量、操作数、方法出口等）
       2.JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）
       3.栈属于线程私有，不能实现线程间的共享！
       4.栈的存储特性是：“先进后出，后进先出”
       5.栈是由系统自动分配，速度快！栈是一个连续的内存空间！
      * 堆的特点如下：
       1.堆用于存储创建好的对象和数组（数组也是对象）
       2.JVM只有一个堆，被所以线程共享
       3.堆是一个不连续的内存空间，分配灵活，速度慢！
       4.堆被所有线程共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。
      * 方法区（特性也是堆）特点如下：
       1.方法区是JAVA虚拟机规范，可以有不同的实现。
            i.  JDK7以前是“永久代”
           ii.  JDK部分去除“永久代”，静态变量‘字符串常量池都挪到了堆内存中
          iii.  JDK8是“元数据空间”和堆结合起来。
       2.JVM只有一个方法区，被所有线程共享！
       3.方法区实际也是堆，只是用于存储类、常量相关的信息！
       4.用来存放程序中永远不变或唯一的内容。（类信息【Class对象，详见反射机制】、静态变量、字符串常量等）
       5.常量池主要存放常量：如文本字符串、final常量池
*//*@对象(Object)与类(Class)
	* 类
	 * 定义格式：
	 [修饰符] class 类名 {				//进阶：[修饰符] class 类名 [extends 父类名] [implements 接口名]{}
		//类体
	 }
	 * 类 = 属性(状态特征) + 方法(动作特征)
	 * * 类 = 属性 + 方法		//属性(状态特征)；方法(动作特征)
	 * 其中属性是以数据的方式存在的，而数据在程序中只能放在变量中，因此属性是以变量的形式存在的，属性=变量(成员变量)
	public class 每一个源文件必须有且只有一个public class，并且类名和文件名保持一致！
    class SecondClass {}     一个源文件中可以包含多个类，每个类都会对应生成一个字节码文件。
    * 类体中有三种成员：属性field、方法method、构造器constructor
	 * 细分为：
	   实例变量、实例方法、静态变量、静态方法、构造方法、静态代码块、实力语句块
    * 属性(field 成员变量)：属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。在定义成员变量时可以对其初始化，如果不对其初始化，系统会在构造器执行的过程中使用默认的值对其初始化。
     * 成员变量的默认值（详见Student.java）：
        整型（0）、浮点型（0.0）、字符型（'\u0000'）、布尔型（false）、所有引用类型（null）
     * 属性定义格式：
        [修饰符] 属性类型 属性名  = [默认值];
	 * 编译过程
		当创建对象过程中变量的数据类型为引用数据类型且为源文件之外的类时，按理应该先编译源文件外部的类再编译源文件，
		但以编译器的角度看，当编译主源文件时会自动寻找为该类名的字节码文件，如果没有对应的字节码文件还回去寻找对应类的java源文件，如果有则会自动编译该文件。
		因此，直接编译含有外部类名作为对象数据类的源文件时，能够自动编译外部类所在源文件，可以不手动编译它。
	 * 
	* 对象(Object)
	 * 使用 new 关键字创建对象. 这是常用的创建对象的方法，语法格式如下：数据类型 变量名 = new 类名 ();		//所有的类都属于数据类型中的引用数据类型，此处可以写类名。
      * 创建对象的四步：
       2.执行属性值的显式初始化(给初始化的属性赋值)
       1.分配对象空间，并将对象成员变量初始化为0或空
       3.执行构造方法
       4.返回对象的地址给相关的变量
	 */
  //执行过程中类最先被加载，存放在方法区中，因此方法区是最先有数据的。
    public static void testObjectClass() {        //case 1：@对象(Object)与类(Class)测试testObjectClass
        //执行过程中上面一行使方法被调用，此时压栈，该方法需要的内存在栈中分配，栈中主要存储局部变量（方法中声明的）。
		//一个学生类已经在外部提前创建好了（原解压后本目录下的Student.java）
		
		//创建一号学生对象，会在堆中开辟一块内存空间。
		Student s1/*s1是引用*/ = new Student();		//通过new运算符创建对象，存储在堆内存当中，堆中开辟Student类一号对象的空间，该空间包含该对象的属性，即实例变量，实例变量都存储在堆内存的对象内部。
		/*堆内存中对象的内存地址会赋给s1变量，像s1变量这种保存了堆中对象内存地址的变量被叫做引用*/
		
		//创建二号学生对象，会在堆中开辟一块新的内存空间，独立与一号对象
		Student s2/*s2是引用*/ = new Student();		//s1、s2都属于局部变量，位于testObjectClass方法内部。
		//s2存储着第二个对象的内存地址。在调用方法的时候可以传引用，但数据类型要符合（如public void addTest(Student s2){//这样s2也成为了新建方法的局部变量(引用)，存储着与调用该方法的方法的引用相同的对象地址}）

		//此时若要访问对象中的实例变量，使用如右语法即可：引用.实例变量;
		System.out.println("一号对象中的实例变量(同下，此成员变量为该对象下的变量即为实例变量，成员变量不手动初始化时，系统会在构造方法执行的过程中以默认数值初始化)：");
		System.out.println("s1.num(学号) = " + s1.num);
		System.out.println("s1.name(姓名) = " + s1.name);
		System.out.println("s1.age(年龄) = " + s1.age);
		System.out.println("s1.sex(性别) = " + s1.sex);
		System.out.println("s1.address(住址) = " + s1.address);
		System.out.println("\n二号对象中的实例变量：");
		System.out.println("s2.num(学号) = " + s2.num);
		System.out.println("s2.name(姓名) = " + s2.name);
		System.out.println("s2.age(年龄) = " + s2.age);
		System.out.println("s2.sex(性别) = " + s2.sex);
		System.out.println("s2.address(住址) = " + s2.address);

		//可以通过"引用.实例变量 赋值运算符(=) 新的值(需要兼容数据类型);"修改对应地址的对象下的实例变量。
		s1.num = 114514;
		s1.name = "张三";
		s1.age = 24;
		s1.sex = '男';
		s1.address = "迪士尼在逃";
		//此时再去访问一号对象的实例变量：
		System.out.println("赋值后的一号对象中的实例变量：");
		System.out.println("s1.num(学号) = " + s1.num);
		System.out.println("s1.name(姓名) = " + s1.name);
		System.out.println("s1.age(年龄) = " + s1.age);
		System.out.println("s1.sex(性别) = " + s1.sex);
		System.out.println("s1.address(住址) = " + s1.address);
		//由于Java中没有指针，Java程序员无法直接操控堆内存的内存空间，只能通过“引用”(对象的内存地址)去访问它们。
  /*运行结果：（运行过程见图片文件或阅读版）
	@对象(Object)与类(Class)测试testObjectClass：
	一号对象中的实例变量(同下，此成员变量为该对象下的变量即为实例变量，成员变量不手动初始化时，系统会在构造器执行的过程中以默认数值初始化)：
	  s1.num(学号) = 0
	  s1.name(姓名) = null
	  s1.age(年龄) = 0
	  s1.sex(性别) =
	  s1.address(住址) = null

	二号对象中的实例变量：
	 s2.num(学号) = 0
	 s2.name(姓名) = null
	 s2.age(年龄) = 0
	 s2.sex(性别) =
	 s2.address(住址) = null
	赋值后的一号对象中的实例变量：
	 s1.num(学号) = 114514
	 s1.name(姓名) = 张三
	 s1.age(年龄) = 24
	 s1.sex(性别) = 男
	 s1.address(住址) = 迪士尼在逃
  */
  /*对象进阶：
	User类和Address类已经在外部提前创建好了（原解压后本目录下的User.java和Address.java）
  *///家庭住址对象
    System.out.println("\n*对象进阶测试：");
  	Address a = new Address();
	a.city = "翻斗花园";
	a.street = "翻斗街道";
	a.zipcode = "10086";

	//用户对象
	User u = new User();
	u.id = 233;
	u.username = "李姐";
	u.address = a;	//赋值的引用a是栈中该方法的局部变量，存储着堆中Address类型的对象的地址(此地址是该变量的值)，并将该值赋给u.address(赋给了引用u存储地址下的address实例变量，此时引用u地址下实例变量address的值为Address类型的对象的地址)
	//u.address是访问了User里面的Address类型的变量，由于Address是引用类型，所以要么赋值一个内存地址，要么不赋值(null)。倘若赋值了一个内存地址，u.address就可以通过引用(address).实例变量(如city)访问Address里面所有的实例变量(总写为：引用.实例变量1/引用2（引用存储地址指向的对象下的实例变量，此时假设该变量为引用数据类型且被赋值一个内存地址作为值，也可以称之为引用(2号)）.实例变量2（指向对象下的实例变量)。
	//address数据类型为类名称Address(见User.java)，由于赋值内容数据类型要与承载数据的变量数据类型相兼容，所以需要address类型的数据才能赋给address类型的变量。
	System.out.println("用户ID：u.id = " + u.id);
	System.out.println("用户名：u.username = " + u.username);
	System.out.println("用户地址测试：u = " + u);	//打印引用u会打印出该局部变量存储的地址(类名+@+hashCode值(哈希值))。
	System.out.println("用户地址测试：u.address = " + u.address);	//由于该实例变量(address)本身没有值，打印的是引用指向对象下实例变量(引用2)存储的地址。
	System.out.println("用户地址下城市：u.address.city = " + u.address.city);

	u = null;	//可以像这样清除引用存储的对象地址，注意：如果一个对象没有被任何一个引用指向，GC会将该对象视为垃圾并回收
	//System.out.println(u.id);		//u(前引用)存储的值是null，不过编译器只检查java语法，能通过编译，但由于该地址是空的，所以无法访问到对象下的id实例变量，导致无法运行（报错：NullPointerException空指针异常）
  /*对象进阶运行结果：
	*对象进阶测试：
	 用户ID：u.id = 233
	 用户名：u.username = 李姐
	 用户地址测试：u = User@66a29884
	 用户地址测试：u.address = Address@4769b07b
	 用户地址下城市：u.address.city = 翻斗花园
  */
	}
  /*@构造方法(构造器constructor)
     * 构造器用于对象的初始化，而不是创建对象！
     * 在创建对象的第三步需要执行构造方法
     * 声明格式：
         [修饰符] 构造方法名 (形参列表){		//构造器的方法名必须和类名一致！
             需要执行的语句;	//即使是没有手动赋值的变量系统也会进行默认赋值
         }
	 * 如果我们没有定义构造器，则编译器会自动定义一个无参的构造方法。如果已定义则编译器就不会自动添加！
     * 前创建对象中的类名实际上就是构造方法名(后面有括号)，但构造方法名必须为类名，所以类名、构造方法名在书面上都一样。
     * 构造器通过new关键词调用！
     * 构造方法是可以重载的，在一个类中的构造方法可以有多个，但每个参与重载的独立构造方法的形参列表都要不同。
	 * 构造器虽然有返回值，但是不能定义返回值类型，返回的就是我建好的类的对象（返回值的类型肯定是本类），不能在构造器里使用return返回某个值。
*///构造方法(构造器)测试：     //case 2：@构造方法(构造器constructor)测试testConstructor
	//测试一：通过构造方法的重载来快速对对象初始化
	int number;
	String name;
	int age;
	JavaEveryday(int 数字,String 你的名字){
		number = 数字;
		name = 你的名字;
	}
	JavaEveryday(int 数字,String 你的名字,int 年龄){
		number = 数字;
		name = 你的名字;
		age = 年龄;
	}
	//测试二：求一点到原点的距离
	double x,y;
    boolean live;
    JavaEveryday(double _x,double _y){     //带参数的构造器
        x = _x;     //this.x = _x;      下划线的作用是为了区分
        y = _y;     //this.y = _y;
    }
    JavaEveryday(int _x){       //构造方法的重载与方法的重载相似，在idea里可以使用Generate快捷生成构造器，按shift可以多选，这让我们可以在处理复杂属性的类中提高效率。
        x = _x;
    }
	JavaEveryday(){}		//无参的构造方法。
    public double getDistance(JavaEveryday p){      //需要传一个参数给p
        return Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));      //开方，根据勾股定理与直角三角形求两点间距离即为两点所在直角三角形的斜边c=根号下√(a²+b²)
    }
    public static void testConstructor(){
        JavaEveryday u1 = new JavaEveryday(12345,"三水");
		JavaEveryday u2 = new JavaEveryday(23333,"立花",17);
		System.out.println("构造器测试一：\nu1.name = "+ u1.name + "；u1.age = "+ u1.age);		//即使年龄没有手动赋值，系统也会给它以默认值初始化。
		System.out.println("u2.name = "+ u2.name + "；u2.age = "+ u2.age);
		
		JavaEveryday p1 = new JavaEveryday(3.0, 4.0);       //先new会创建一个新的对象，其中第三步new JavaEveryday执行上面的构造器。
        JavaEveryday origin = new JavaEveryday(0.0, 0.0);
        System.out.println("构造器测试二：\n点p1与原点origin的距离="+p1.getDistance(origin));     //将变量origin的值传给p，参数p的地址就指向origin指向的对象(被传参_x=0.0,_y=0.0的JavaEveryday)，这样，上面的p.x就是p地址中的x = _x = 0.0,p.y相同。
    
	/* 额外补充(与构造方法无关，与方法局部变量注意事项的举例相区分)：程序执行过程的内存之参数传值机制：
         Java中所有参数都是“值传递”，也就是“传递的是值的副本”。也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件
       * 基本数据类型参数的传值：传递到是值的副本。副本不会影响原件
       * 引用类型参数的传值：传递的是值的副本。但引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值”，也意味着原参数指向对象的值发生改变。
    */
        p1.live = true;
        JavaEveryday p2 = p1;
        System.out.println("参数传值机制测试：\np1地址下的live原值为"+p1.live);
        p2.live = false;        //将p2的地址对象的值改为原点，则p1地址指向的值也为原点。
        System.out.println("p2地址指向的对象的值改变后，和p2地址指向对象相同的p1指向对象的live值也变为"+p1.live);
    }
  /*执行结果：
    @构造方法(构造器constructor)测试testConstructor：
    构造器测试一：
	u1.name = 三水；u1.age = 0
	u2.name = 立花；u2.age = 17
	构造器测试二：
    点p1与原点origin的距离=5.0
    参数传参机制测试
    p1地址下的live原值为true
    p2地址指向的对象的值改变后，和p2地址指向对象相同的p1指向对象的live值也变为false
  */
  /*@面向对象的三大特征（封装、继承、多态）：
	  * 封装(Encapsulation)
		引入：
		 1.现实中有很多例子，如手机、电脑、照相机、遥控器等，通过对内部的封装来保护内部的安全，还能够让使用者屏蔽内部的复杂结构
		 2.对于代码而言，假设一类体中的数据封装后，可以屏蔽复杂的实现代码，只需要一个简单的入口就可以访问。另外，类体中安全级别较高的数据封装起来，为外部人员的访问设置障碍，以此能够保障数据的安全性。
		 3.作用总结：一：保证内部结构的安全；二：屏蔽复杂，暴露简单。
*//*	封装：
			int secret = 100;	//secret属性是暴露的，在程序外部可以随意访问。
		 1.属性私有化(使用private关键字进行修饰)
		 2.对外提供简单的操作入口。
			//pravite 表示私有的，被该关键词修饰后，被修饰的数据只能在本类中访问，在其他类中都无法直接访问。
			private int secret;		//离开本类，secret无法被访问和修改

			//对外提供简单的访问入口(详见TestEncapsulation.java)
			public void method(){	//该方法没有static修饰，像这样的方法被称为：实例方法(对象方法)
			//注意：没有static修饰的方法在调用时需要先用new关键词创建出对象，再使用"引用.实例方法名"的语法调用；若是有static修饰的方法，调用时只需通过"类名.方法名"就可以直接调用}
	*///封装(Encapsulation)测试：     //case 3：@封装(Encapsulation)测试testEncapsulation(详见TestEncapsulation.java)
	public static void testEncapsulation(){
		//通过"类名.方法名"不能访问没有被static修饰的方法(如TestEncapsulation类下getPassword和setPassword方法)
		//get方法(同set命名规范见TestEncapsulation)
		//调用getPassword方法的错误示范：TestEncapsulation.getPassword;	//只有方法修饰符列表中有static时，才能使用该语法访问。
		//调用getPassword方法的正确操作：
		TestEncapsulation e1 = new TestEncapsulation();
		//int miMa = e1.getNumber();
		//System.out.println(miMa);
		//以上被注释两行可替换为下面一行，与println()方法的临时变量有关，详见前面的方法部分或方法调用部分FirstPart下case13
		System.out.println("密码password为：" + e1.getPassword());
		
		//set方法(设卡详见TestEncapsulation.java)
		e1.setPassword(999999);
		System.out.println("密码被修改为：" + e1.getPassword());
		e1.setPassword(666);
	}
  /*修饰符static
  	* static译为“静态”，修饰方法即静态方法，修饰变量即静态变量(变量分为 局部变量 和 成员变量（详见变量）)
	 * static静态代码在类加载时执行，且只能执行一次。
	 * 成员变量可再分为 实例变量 和 静态变量；方法分为 实例方法 和 静态方法*/
	  //以下的实例都与对象相关，访问时采用"引用."的方式访问，且需要先new对象，才能后续访问，否则可能会导致空指针异常错误。
	   int 成员变量的实例变量;	//在方法体 外 声明的变量被称为 成员变量(下分 实例变量 和 静态变量)
	   public void 实例方法(){}	//方法体{} 内 声明的变量才叫做 局部变量
	  //以下的静态都与类相关，访问时采用"类名."的方式访问，无需new对象，不会发生空指针异常的错误
	   static int 成员变量的静态变量;
	   public static void 静态方法(){}	//无论是实例方法、静态方法还是构造方法，执行时都会压栈
																			/*
	* 所有static关键字修饰的都是类相关的，类级别的，且都采用"类名."的方式访问。
 *///@修饰符Static测试：     //case 4：@修饰符Static测试testStatic
	public static void testStatic(){
		
		System.out.println("StaticClass.biome --> " + StaticClass.biome);	//静态变量通过"类名.静态变量名"访问，不需要new对象也可访问，且在类加载时初始化值。
		StaticClass.breath();	//静态方法不需要创建对象也可以通过"类名.方法名"执行，若非要使用"引用.方法名"执行静态方法也需要先创建对象才能执行。
		StaticClass c1 = new StaticClass("7355608","李明");
		System.out.println("c1.name --> " + c1.name);
		System.out.println("c1.idCard --> " + c1.idCard);
		//实例的只能通过"引用."来访问，静态的则使用"类名."，且"引用."也可以访问，但不便于区分。(只有"空引用"在访问实例相关内容才会报空指针异常，对于静态而且，该引用无论值如何等同于类名)
		System.out.println(c1.getId());
		c1.breath();	//使用"引用.方法名"来执行静态方法（不推荐）
	}
	//@静态代码块
	//静态代码块在类加载时执行，并且在main方法执行之前执行。
	static {	//按照由上到下顺次执行。
		System.out.println("欢迎浏览个人笔记");
	}
	static String 数 = "数字"; //静态代码块与静态相关代码互为并列关系且存在先后顺序。(可以理解为静态相关内容处于一个独立的空间)
	static {
		System.out.println("本类通过输入" + 数 + "来控制需要执行的方法");
	}
	//@实例语句块
	//在构造方法执行之前执行，详见StaticClass.java（格式相同但不同于方法内的语句块）
   /*执行结果：
   	 @修饰符Static测试testStatic：
	  StaticClass.biome --> null
	  呼&吸
	  构造器被使用，实例语句块执行
	  c1.name --> 李明
	  c1.idCard --> 7355608
	  7355608
	  呼&吸
 *//*@番外（各类变量与方法总结）：
	 * 变量
	  * 局部变量，存储在 栈 中，在 方法 执行时开辟空间；只能在同一个作用域中直接通过变量名调用
	  * 成员变量
	   * 实例变量，存储在 堆 中，在 构造方法 执行时，对象创建时，分配空间；通过"引用.变量名"访问。
	   * 静态变量，存储在 方法区 中，在类加载时初始化，分配空间；通过"类名.变量名"访问
	 * 方法
	  * 静态方法，对象创建后通过"引用.方法名"访问，在构造方法执行前执行
	  * 实例方法，直接采用"类名.方法名"访问
	  * 构造方法，用于对象实例变量的初始化，可以在构造方法间通过方法内第一行写"this(形参值)"来调用其它构造方法。
 *//*@关键词this测试：		//case 5：@关键词this测试testThis
	* this是一个关键字，也是变量(等同于引用的变量)
	* this变量(引用)保存当前对象的内存地址，存储在堆内存当前对象内部且指向该对象本身
	* this只能使用在实例方法中，因为它本身作为引用存储的是对象的地址。
	* this在绝大部分情况下都是可以省略的，不能省略的情况详见Student.java的构造方法部分
	--这里以Student类为例，创建两个对象。*/
	public static void testThis(){
		Student s1 = new Student("王五","011");
		Student s2 = new Student("王红","012");
		s1.sleep();	//实例方法通过"引用.方法名"调用
		s2.test();
	}
    /*@this()用法：
	 * this可以在构造方法中调用本类下的另一个构造方法，提高代码复用性
	 * 语法格式：
	 	this(实际参数列表);
	 * 注意事项：
	  * 调用的构造方法必须和本身处于同一个类中。
	  * this()在使用时只能出现在构造方法的第一行。
	 * 实战详见Student.java类中构造方法部分
*//*执行结果：
	  @关键词this测试testThis
	  考号为011的考生王五正在睡觉
	  考号为012的考生王红正在应考
	*/
 /*@面向对象的三大特征（封装、继承、多态）：
	* 继承(extends)
	  引入：
	   * 例如现实中子承父业，财产继承等，顾名思义就是被继承者的东西传递给继承者，让继承者拥有被继承者的东西。
	  类的继承与格式：
	   * 继承分有子类和父类，子类是继承者，能够拥有父类的所有属性和方法，但不能继承构造方法且私有的属性无法在子类中访问(即父类中pravite修饰的不能在子类中直接访问，但可以通过间接手段访问)。
	   * 格式：
	   		[修饰符] class 类名A(subclass)(子类、派生类‘扩展类) extends 类名B(superclass)(父类、基类、超类){
				//此处省略B类下的所有属性和方法（A类继承B类的所有属性和方法）
			}
	  继承作用：
	  	* 基本作用：子类继承父类，代码可以得到复用。（继承的基本作用测试详见ExtendsTest.java）
		* 主要(重要)作用：有了继承
	  java继承说明：
		* java只继承单继承，不允许多继承。(C++支撑多继承)（java可以间接继承）
		* 一个类即使没有明确编写继承的类也会默认继承Object，这意味着Object是所有类对象的超类，是类体系结构中的根，也就是说，任一对象与生俱来就有Object类型中的所有的特征。
		* 继承存在缺点，如：会提高整个程序的耦合度(父类修改，子类也受牵连)
	  默认继承的Object类：
	    * 重新审视System.out.println("Hello world");
		System.out 中，out后面没有小括号，说明out是变量名
		另外System.out是一个类名，直接使用类名System.out，说明out是一个静态变量名。
		System.out返回一个对象，然后采用“对象.”的方式访问peintln()方法。
		该类下面有许多方法，其中我们抽取toString()方法进行介绍。（详见ExtendsTest.java）
	  方法的覆盖/重写(Override/Overwrite)
		* 是指将继承父类来的方法重写，使新方法覆盖相同定义的旧方法，让调用对应方法名时反馈新写方法的结果。
		* 构成覆盖的要求：（区别于方法的重载，重载仅是重名）
		 1.两个人必须要有继承关系。
		 2.两个方法要有相同的定义(相同的返回值类型、方法名、形式参数列表、访问修饰符(访问权限可以更高但不能更低)等)
		 3.重写之后的方法不能比原方法抛出更多的异常，但可以更少。
		* 覆盖的注意事项：
		 1.方法覆盖只是针对方法，与属性无关。
		 2.私有方法无法被覆盖。
		 3.构造方法(不会被继承)无法被覆盖
		 4.方法覆盖只是针对于实例方法，静态方法覆盖没有意义。
		* 覆写继承Object类的toString方法实例：
		 * 由于我们可以在子类覆写从父类继承来的方法以满足更宽泛的业务需求。
		 * ————详见ExtendsTest.java
    /*@面向对象的三大特征（封装、继承、多态）：
	   * 多态(Polymorphic)（重点）
	    * 前言：java中支持一个语法：
			父类型(父类类名-数据类型) 引用 = new 子类名(子类构造方法)(); 
		  父类型的引用允许指向子类型的对象
	    * 必备概念：
		 1.向上转型(子————>父)(类似自动类型转换(但不是，本身是基本数据类型的，此处方便理解))
		 2.向下转型(父————>子)(类似强制类型转换，需要加强制类型转换符(但不是，本身是基本数据类型的，此处方便理解))
		* 注意事项：
		 1.无论是向上还是向下转型，两个类之间必须有继承关系，否则会编译器报错。
  *//*@Java垃圾回收机制(Garbage Collection)：
    * 垃圾回收原理：
     * 内存管理
       Java的内存管理很大程度就是：堆中对象的管理，其中包括对象空间的分配与释放。
       对象空间的分配：使用new关键字创建对象即可
       对象空间的释放：将对象赋值null即可
     * 垃圾回收过程
       任何一种垃圾回收算法一般要做两件基本的事情：
       1.发现无用的对象
       2.回收无用对象占用的内存空间
       垃圾回收机制保证可以将“无用的对象”进行回收。
       无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。
     * 垃圾回收相关算法
       1.引用计数法：
         堆中的每个对象都对应一个引用计数器。当有引用指向这个对象时，引用计数器加1，而当指向该对象的引用失效时（引用变为null），引用计数器减1，
         最后如果该对象的引用计算器的值为0时，则Java垃圾回收器会认为该对象是无用对象并对其进行回收。有点是算法简单，缺点是“循环引用的无用对象”无法识别。
       2.引用可达法(根搜索算法)
         程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，
         当所有的引用节点寻找完毕以后，剩余的节点则被认为没有被引用到的节点，即无用的节点。
     * 通用的分代垃圾回收机制
     * 关键词知识点
      * Eden区 存储了从未通过垃圾回收的新对象；Survivor区（分为Survivor 1 与Survivor 2） 存放垃圾回收后 ，仍然有用的对象。循环存放，小于N（15）次垃圾回收次数；Tenured区 年老代区域存放超过N（15）次未被回收的对象
      * Minor GC:
            用于清理年老代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用的对象复制到“Survivor 1”、“Survivor 2”区中。
      * Major GC:
            用于清理老年代区域。
      * Full GC:
            用于清理年轻代、年老代、永久代区域。成本较高，会对系统性能产生影响。
     * 分代垃圾回收机制，是基于这样的一个事实：不同的对象的生命周期是不一样的。
        因此，不同生命周期的对象可以采用不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、永久代。同时，将处于不同状态的对象放在堆中不同的区域。
      1.年轻代
            所有新生成的对象首先都是放在Eden区。年轻代的目的就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，
        MinorGC会清理年轻代的内存，算法采用效率较高的复制算法，但是频繁的操作会造成内存空间的浪费。
        当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
      2.年老代
            在年轻代经历了N次（默认15次）垃圾回收仍然存活的对象会被存放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
        老年代对象越来越多，我们就需要启动Major GC或Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。
      3.永久代
            用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。JDK7以前就是“方法区”的一种实现。
        JDK8以后已经没有“永久代”了，使用metaspace元数据空间和堆替代。
     * JVM调优和Full GC
        在对JVM调优的过程中，很大一部分工作就是对Full GC的调节。有以下原因 有可能 导致启动Full GC：
          1.年老代(Tenured)被写满
          2.永久代(Perm)被写满
          3.System.gc()被显式调用        //建议调用，仍由系统决定。
          4.上一次GC之后Heap的各域分配策略动态变化
	 */






















		static String Mainwelcome = "输入负整数以切换章节（如：-1为第一章，-2为第二章），输入\"0\"以退出程序，请输入章节序号进入章节\n";
        static String MainfirstPart = "------------第一篇章：Java入门------------输入\"-1\"进入该章节\n@变量测试testVariable\n@常量测试testConstant\n@整型常、变量和各种进制testInt\n@浮点型测试testFloatNumber\n@字符型与转义字符测试testChar\n@布尔型测试testBoolean\n@运算符测试testOperator\n@Scanner接收用户键盘输入测试testKeyInput\n@If语句测试testIf\n@Switch多分支结构测试(与if对比)testSwitch\n@循环结构测试testLoops\n@break和continue语句以及带标签的break和continue语句测试testBreakAndContinue\n@方法(method)语句测试testMethod\n@递归(recursion)结构测试testrecursion\n";
        static String MainsecondPart = "------------第二篇章：对象与类与内存分析------------输入\"-2\"进入该章节\n@对象(Object)与类(Class)测试testObjectClass\n@构造方法(构造器constructor)测试testConstructor\n@封装(Encapsulation)测试testEncapsulation\n@修饰符Static测试testStatic\n@关键词this测试testThis\n";
        

    static void FirstPart(){
		String welcome = "输入整数序号以运行程序，输入\"0\"以退出该章节\n";
        String firstPart = "------------第一篇章：Java入门------------\n输入\"1\"运行 @变量测试testVariable\n输入\"2\"运行 @常量测试testConstant\n输入\"3\"运行 @整型常、变量和各种进制testInt\n输入\"4\"运行 @浮点型测试testFloatNumber\n输入\"5\"运行 @字符型与转义字符测试testChar\n输入\"6\"运行 @布尔型测试testBoolean\n输入\"7\"运行 @运算符测试testOperator\n输入\"8\"运行 @Scanner接收用户键盘输入测试testKeyInput\n输入\"9\"运行 @If语句测试testIf\n输入\"10\"运行 @Switch多分支结构测试(与if对比)testSwitch\n输入\"11\"运行 @循环结构测试testLoops\n输入\"12\"运行 @break和continue语句以及带标签的break和continue语句测试testBreakAndContinue\n输入\"13\"运行 @方法(method)语句测试testMethod\n输入\"14\"运行 @递归(recursion)结构测试testrecursion\n";
        System.out.println(welcome + firstPart);
        main:while(true) {
            Scanner scan = new Scanner(System.in);
            String m = scan.next();
	  		System.out.println(welcome + firstPart + "\n\n\n\n");
            switch (m) {
            case "0":
                System.out.println(Mainwelcome + MainfirstPart + MainsecondPart + "\n\n\n\n");
                break main;
            case "1":
                System.out.println("@变量测试testVariable：");
                testVariable();
                break;
            case "2":
                System.out.println("@常量测试testConstant：");
                testConstant();
                break;
            case "3":
                System.out.println("@整型常、变量和各种进制testInt：");
                testInt();
                break;
            case "4":
                System.out.println("@浮点型测试testFloatNumber：");
                testFloatNumber();
                break;
            case "5":
                System.out.println("@字符型与转义字符测试testChar：");
                testChar();
                break;
            case "6":
                System.out.println("@布尔型测试testBoolean：");
                testBoolean();
	  		    break;
            case "7":
                System.out.println("@运算符测试testOperator：");
                testOperator();
                break;
            case "8":
                System.out.println("@Scanner接收用户键盘输入测试testKeyInput：");
                testKeyInput();
                break;
	  		case "9":
                System.out.println("@If语句测试testIf：");
                testIf();
                break;
            case "10":
                System.out.println("@Switch多分支结构测试(与if对比)testSwitch：");
                testSwitch();
                break;
            case "11":
                System.out.println("@循环结构测试testLoops：");
                testWhile();
                testFor();
                testloop2();
                break;
            case "12":
                System.out.println("@break和continue语句以及带标签的break和continue语句测试testBreakAndContinue：");
                testBreakAndContinue();
                break;
            case "13":
				System.out.println("@方法(method)语句测试testMethod：");
                System.out.println("第一次调用(赋值g=10)：\n" + testMethod(10) + "\n\n第二次调用(赋值g=11)：");		//方法的执行可以放在System.out.println();的括号内，且会先执行方法，然后打印结果(如只执行方法不会打印结果)，总体System.out.println()的输出内容：方法>>在调用方法前的内容>>调用的方法结果>>在调用方法后的内容
				System.out.println(testMethod(11));
				break;
            case "14":
                System.out.println("@递归(recursion)结构测试testrecursion：");
                testrecursion();
                break;
            default:
                System.out.println("无效字符！");
                break;
            }
            System.out.println("\n\n\n\n");
        }
  }
    public static void SecondPart(){
		String welcome = "输入整数序号以运行程序，输入\"0\"以退出该章节\n";
        String secondPart = "------------第二篇章：对象与类与内存分析------------\n输入\"1\"运行 @对象(Object)与类(Class)测试testObjectClass\n输入\"2\"运行 @构造方法(构造器constructor)测试testConstructor\n输入\"3\"运行 @封装(Encapsulation)测试testEncapsulation\n输入\"4\"运行 @修饰符Static测试testStatic\n输入\"5\"运行 @关键词this测试testThis\n";
        System.out.println(welcome + secondPart);
        main:while(true) {
            Scanner scan = new Scanner(System.in);
            String m = scan.next();
			System.out.println(welcome + secondPart + "\n\n\n\n");
            switch (m) {
            case "0":
                System.out.println(Mainwelcome + MainfirstPart + MainsecondPart);
                break main;
            case "1":
                System.out.println("@对象(Object)与类(Class)测试testObjectClass：");
                testObjectClass();
                break;
            case "2":
                System.out.println("@构造方法(构造器constructor)测试testConstructor：");
                testConstructor();
                break;
			case "3":
				System.out.println("@封装(Encapsulation)测试testEncapsulation：");
                testEncapsulation();
                break;
			case "4":
                System.out.println("@修饰符Static测试testStatic：");
                testStatic();
                break;
			case "5":
				System.out.println("@关键词this测试testThis");
				testThis();
				break;
            default:
                System.out.println("无效字符！");
                break;
            }
			System.out.println("\n\n\n\n");
        }
    }
    public static void main (String[] args) {
        System.out.println(Mainwelcome + MainfirstPart + MainsecondPart);
        main:while(true) {
            Scanner Wscan = new Scanner(System.in);
            String n = Wscan.next();
                switch(n) {
                case "0":
                    break main;
                case "-1":
                    FirstPart();
                    break;
                case "-2":
                    SecondPart();
                    break;
                default:
                    System.out.println("无效字符");
                    break;
                }
        }
    }
}

